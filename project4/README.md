# Project 4: SM3的软件实现与优化

## 项目概述

本项目实现了SM3密码杂凑算法的软件优化实现，并基于SM3构建了相关应用：
1. SM3算法的基本实现及性能优化
2. 基于SM3的长度扩展攻击验证
3. 基于RFC6962标准的Merkle树构建与证明生成

## SM3算法数学原理

### 1. SM3算法结构

SM3是一种密码杂凑函数，产生256位的杂凑值。其设计基于Merkle-Damgård结构，具体计算过程如下：

#### 1.1 填充规则

对于长度为`l`比特的消息`m`，填充过程为：
1. 在消息后追加比特"1"
2. 追加`k`个"0"，其中`k`是满足`l + 1 + k ≡ 448 (mod 512)`的最小非负整数
3. 追加64位的消息长度`l`（二进制表示）

填充后的消息长度为512的倍数。

#### 1.2 初始值

8个初始杂凑值（每个32位）：
```
IV₀ = 0x7380166F
IV₁ = 0x4914B2B9
IV₂ = 0x172442D7
IV₃ = 0xDA8A0600
IV₄ = 0xA96F30BC
IV₅ = 0x163138AA
IV₆ = 0xE38DEE4D
IV₇ = 0xB0FB0E4E
```

#### 1.3 压缩函数

对于每个512位的消息分组`B^(i)`，执行压缩函数`CF`：

```
V^(i+1) = CF(V^(i), B^(i))
```

其中`V^(0) = IV`，最终输出为`V^(n)`。

### 2. 压缩函数详细设计

#### 2.1 消息扩展

将512位消息分组`B`分解为16个32位字`W₀, W₁, ..., W₁₅`，然后扩展为132个字：

```
Wⱼ = P₁(Wⱼ₋₁₆ ⊕ Wⱼ₋₉ ⊕ (Wⱼ₋₃ ≪ 15)) ⊕ (Wⱼ₋₁₃ ≪ 7) ⊕ Wⱼ₋₆
```
对于`j = 16, 17, ..., 67`

其中置换函数`P₁(X) = X ⊕ (X ≪ 15) ⊕ (X ≪ 23)`

另一组扩展字：
```
W'ⱼ = Wⱼ ⊕ Wⱼ₊₄
```
对于`j = 0, 1, ..., 63`

#### 2.2 压缩函数主循环

设压缩函数`CF`的输入为256位字符串`V = A||B||C||D||E||F||G||H`，压缩函数的计算过程如下：

```
FOR j = 0 TO 63
    SS₁ = ((A ≪ 12) + E + (Tⱼ ≪ j mod 32)) ≪ 7
    SS₂ = SS₁ ⊕ (A ≪ 12)
    TT₁ = FFⱼ(A,B,C) + D + SS₂ + W'ⱼ
    TT₂ = GGⱼ(E,F,G) + H + SS₁ + Wⱼ
    D = C
    C = B ≪ 9
    B = A
    A = TT₁
    H = G
    G = F ≪ 19
    F = E
    E = P₀(TT₂)
ENDFOR
```

#### 2.3 布尔函数

```
FFⱼ(X,Y,Z) = {
    X ⊕ Y ⊕ Z,           j = 0,1,...,15
    (X ∧ Y) ∨ (X ∧ Z) ∨ (Y ∧ Z), j = 16,17,...,63
}

GGⱼ(X,Y,Z) = {
    X ⊕ Y ⊕ Z,           j = 0,1,...,15
    (X ∧ Y) ∨ (¬X ∧ Z),   j = 16,17,...,63
}
```

#### 2.4 置换函数

```
P₀(X) = X ⊕ (X ≪ 9) ⊕ (X ≪ 17)
```

#### 2.5 常数

```
Tⱼ = {
    0x79CC4519, j = 0,1,...,15
    0x7A879D8A, j = 16,17,...,63
}
```

## 算法优化策略

### 1. 基础优化

#### 1.1 循环展开
将64轮的主循环部分展开，减少循环开销和条件判断。

#### 1.2 位运算优化
- 使用位移操作替代乘除法
- 合并多个位运算操作
- 利用编译器内建函数进行循环左移

#### 1.3 内存访问优化
- 减少不必要的内存访问
- 使用寄存器变量存储中间结果
- 优化数据结构布局

### 2. 高级优化

#### 2.1 SIMD指令集优化
利用SIMD指令并行处理多个数据块，特别是在消息扩展阶段。

#### 2.2 查表优化
对于某些重复计算的部分，预计算结果并存储在查找表中。

#### 2.3 流水线优化
合理安排指令顺序，充分利用CPU的流水线特性。

## 长度扩展攻击原理

### 攻击原理

SM3算法基于Merkle-Damgård结构，存在长度扩展攻击的安全风险。攻击者在已知杂凑值`H(M)`而不知道消息`M`的情况下，可以计算出`H(M || padding || M')`的值，其中`M'`是攻击者选择的任意消息。

### 数学描述

设原始消息为`M`，其杂凑值为：
```
H(M) = SM3(M)
```

攻击者可以构造新消息：
```
M_new = M || padding(M) || M'
```

其中`padding(M)`是对`M`的标准填充，`M'`是攻击者选择的扩展消息。

攻击者可以直接计算：
```
H(M_new) = CF(H(M), M')
```

而无需知道原始消息`M`的内容。

### 攻击条件

1. 攻击者知道`H(M)`的值
2. 攻击者知道消息`M`的长度
3. 攻击者可以控制扩展的消息内容

## Merkle树实现原理

### 1. Merkle树结构

根据RFC6962标准，Merkle树是一种二叉树结构，用于高效验证大量数据的完整性。

#### 1.1 叶子节点计算

对于数据项`d`，叶子节点的杂凑值为：
```
MTH({d}) = SM3(0x00 || d)
```

#### 1.2 内部节点计算

对于两个子节点的杂凑值`left`和`right`，父节点的杂凑值为：
```
MTH(left, right) = SM3(0x01 || left || right)
```

#### 1.3 树的递归构造

对于`n`个元素的列表`D[n] = {d₀, d₁, ..., d_{n-1}}`：

- 当`n = 0`时：`MTH({}) = SM3("")`
- 当`n = 1`时：`MTH({d₀}) = SM3(0x00 || d₀)`
- 当`n > 1`时：设`k`为小于`n`的最大2的幂，则：
  ```
  MTH(D[n]) = SM3(0x01 || MTH(D[0:k]) || MTH(D[k:n]))
  ```

### 2. 存在性证明（Inclusion Proof）

#### 2.1 审计路径

对于叶子节点`d_m`在树中的存在性证明，需要提供从叶子到根的审计路径`PATH(m, D[n])`：

- 当`n = 1`时：`PATH(0, {d₀}) = {}`
- 当`n > 1`时：
  - 若`m < k`：`PATH(m, D[n]) = PATH(m, D[0:k]) + {MTH(D[k:n])}`
  - 若`m ≥ k`：`PATH(m, D[n]) = PATH(m-k, D[k:n]) + {MTH(D[0:k])}`

#### 2.2 验证过程

验证者使用审计路径重新计算根杂凑值，与已知的根进行比较。

### 3. 一致性证明（Consistency Proof）

一致性证明用于验证树的append-only属性，即新树包含旧树的所有元素。

对于大小为`m`的旧树和大小为`n`的新树（`m < n`），一致性证明`PROOF(m, D[n])`包含验证两个根杂凑值一致性所需的最小节点集合。

## 实现方案

### 1. 模块结构

```
src/
├── sm3_basic.c         # 基础SM3实现
├── sm3_optimized.c     # 优化版SM3实现
├── length_extension.c  # 长度扩展攻击实现
├── merkle_tree.c      # Merkle树实现
├── sm3.h              # SM3算法头文件
└── merkle.h           # Merkle树头文件

tests/
├── test_sm3.c         # SM3算法测试
├── test_attack.c      # 长度扩展攻击测试
└── test_merkle.c      # Merkle树测试

benchmark/
└── performance.c      # 性能测试程序
```

### 2. 编译配置

使用不同的编译选项测试性能差异：
- `-O0`：无优化基准测试
- `-O2`：标准优化
- `-O3 -march=native`：最高优化
- `-O3 -march=native -funroll-loops`：循环展开优化

## 实验设计与结果

### 1. 性能测试

#### 1.1 测试环境
- CPU: [待测试时填入]
- 编译器: GCC版本
- 操作系统: Linux

#### 1.2 测试方法
对不同长度的消息（1KB, 10KB, 100KB, 1MB）进行杂凑计算，测量吞吐量和延迟。

#### 1.3 性能对比
[实验结果表格将在实际测试后填入]

### 2. 长度扩展攻击验证

#### 2.1 攻击场景
构造一个认证系统，使用`SM3(secret || message)`作为消息认证码，验证攻击的可行性。

#### 2.2 攻击效果
[实验结果将在实际测试后填入]

### 3. Merkle树性能测试

#### 3.1 树构建性能
测试构建10万个叶子节点Merkle树的时间开销。

#### 3.2 证明生成与验证
测试存在性证明和一致性证明的生成与验证时间。

#### 3.3 内存使用
分析不同树大小的内存使用情况。

## 结论

本项目实现了SM3算法的高效软件实现，通过多种优化技术显著提升了算法性能。同时验证了SM3算法的长度扩展攻击漏洞，并实现了基于SM3的Merkle树结构。实验结果表明了各项实现的正确性和性能特征。

## 参考文献

1. GM/T 0004-2012 SM3密码杂凑算法
2. RFC 6962 - Certificate Transparency
3. 付勇老师课程PPT - SM3算法优化技术
